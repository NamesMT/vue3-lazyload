/*!
 * Vue3-Lazyload.js v0.4.0-refactored
 * A Vue3.x image lazyload plugin
 * (c) 2023 MuRong <admin@imuboy.cn>
 * Released under the MIT License.
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("vue")):"function"==typeof define&&define.amd?define(["exports","vue"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).VueLazyload={},e.vue)}(this,function(e,n){"use strict";var s,t;(t=s=s||{}).LOADING="loading",t.LOADED="loaded",t.ERROR="error";const r="undefined"!=typeof window&&null!==window,l=function(){if(r&&"IntersectionObserver"in window&&"IntersectionObserverEntry"in window&&"intersectionRatio"in window.IntersectionObserverEntry.prototype)return"isIntersecting"in window.IntersectionObserverEntry.prototype||Object.defineProperty(window.IntersectionObserverEntry.prototype,"isIntersecting",{get(){return 0<this.intersectionRatio}}),!0;return!1}(),u=Object.prototype.propertyIsEnumerable,d=Object.getOwnPropertySymbols;function g(e){return"function"==typeof e||"[object Object]"===toString.call(e)}function y(e,...t){let r=0;var o,n;for(e=(e=("object"==typeof(o=e)?null===o:"function"!=typeof o)?t[r++]:e)||{};r<t.length;r++)if(g(t[r])){for(const l of Object.keys(t[r]))"__proto__"!==(n=l)&&"constructor"!==n&&"prototype"!==n&&(g(e[l])&&g(t[r][l])?y(e[l],t[r][l]):e[l]=t[r][l]);s=i=void 0;var i=e,s=[t[r]];if(!g(i))throw new TypeError("expected the first argument to be an object");if(0!==s.length&&"function"==typeof Symbol&&"function"==typeof d)for(const a of s)for(const c of d(a))u.call(a,c)&&(i[c]=a[c])}}const a="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",o={rootMargin:"0px",threshold:0},c="data-lazy-timeout-id";class i{constructor(e){this.options={loading:a,error:"",observerOptions:o,log:!0,lifecycle:{}},this._images=new WeakMap,this.config(e)}config(e={}){y(this.options,e)}mount(e,t){var r,o,n,i;e&&({src:t,loading:r,error:o,lifecycle:n,delay:i}=this._valueFormatter("string"==typeof t?t:t.value),this._lifecycle(s.LOADING,n,e),e.setAttribute("src",r||a),this._tryInitIntersectionObserver(e,t,r,o,n,i))}update(e,t){var r,o,n,i;e&&(null!=(r=this._realObserver(e))&&r.unobserve(e),{src:r,loading:t,error:o,lifecycle:n,delay:i}=this._valueFormatter("string"==typeof t?t:t.value),this._tryInitIntersectionObserver(e,r,t,o,n,i))}unmount(e){var t;e&&(null!=(t=this._realObserver(e))&&t.unobserve(e),this._images.delete(e))}_tryLoadImage(t,r,o,e){const n=new Image;return n.src=r,this._listenImageStatus(n,t?(...e)=>{this._setImageSrc(t,r),o&&o.apply(void 0,e)}:o,e),n}loadImage(t,r,e,o,n){this._lifecycle(s.LOADING,n,t),this._setImageSrc(t,e||a),this._tryLoadImage(t,r,()=>{this._lifecycle(s.LOADED,n,t)},()=>{var e;this._listenImageStatus(t,null,null),null!=(e=this._realObserver(t))&&e.unobserve(t),this._lifecycle(s.ERROR,n,t),o&&this._setImageSrc(t,o||""),this._log(()=>{throw new Error(`Image failed to load! And failed src was: ${r} `)})})}_setImageSrc(e,t){"img"===e.tagName.toLowerCase()?e.setAttribute("src",t):e.style.backgroundImage=`url('${t}')`}_tryInitIntersectionObserver(e,t,r,o,n,i){l||(this.loadImage(e,t,r,o,n),this._log(()=>{throw new Error("Not support IntersectionObserver!")})),this._initIntersectionObserver(e,t,r,o,n,i)}_initIntersectionObserver(t,r,o,n,i,s){var e=this.options.observerOptions;this._images.set(t,new IntersectionObserver(e=>{Array.prototype.forEach.call(e,e=>{s&&0<s?this._delayedIntersectionCallback(t,e,s,r,o,n,i):this._intersectionCallback(t,e,r,o,n,i)})},e)),null!=(e=this._realObserver(t))&&e.observe(t)}_intersectionCallback(e,t,r,o,n,i){var s;t.isIntersecting&&(null!=(s=this._realObserver(e))&&s.unobserve(t.target),this.loadImage(e,r,o,n,i))}_delayedIntersectionCallback(e,t,r,o,n,i,s){t.isIntersecting?t.target.hasAttribute(c)||(r=setTimeout(()=>{this._intersectionCallback(e,t,o,n,i,s),t.target.removeAttribute(c)},r),t.target.setAttribute(c,String(r))):t.target.hasAttribute(c)&&(clearTimeout(Number(t.target.getAttribute(c))),t.target.removeAttribute(c))}_listenImageStatus(e,t,r){e.onload=t,e.onerror=r}_valueFormatter(e){let t=e,r=this.options.loading,o=this.options.error,n=this.options.lifecycle,i=this.options.delay;return g(e)&&(t=e.src,r=e.loading||this.options.loading,o=e.error||this.options.error,n=e.lifecycle||this.options.lifecycle,i=e.delay||this.options.delay),{src:t,loading:r,error:o,lifecycle:n,delay:i}}_log(e){this.options.log&&e()}_lifecycle(e,t,r){switch(e){case s.LOADING:null!=r&&r.setAttribute("lazy",s.LOADING),null!=t&&t.loading&&t.loading(r);break;case s.LOADED:null!=r&&r.setAttribute("lazy",s.LOADED),null!=t&&t.loaded&&t.loaded(r);break;case s.ERROR:null!=r&&r.setAttribute("lazy",s.ERROR),null!=t&&t.error&&t.error(r)}}_realObserver(e){return this._images.get(e)}}e.default={install(e,t){const r=new i(t);e.config.globalProperties.$Lazyload=r,e.provide("Lazyload",r),e.directive("lazy",{mounted:r.mount.bind(r),updated:r.update.bind(r),unmounted:r.unmount.bind(r)})}},e.useLazyload=function(t,e){const r=n.ref(null),o=new i(e);return n.onMounted(()=>{r.value&&o.mount(r.value,t.value)}),n.onUnmounted(()=>{r.value&&o.unmount(r.value)}),n.watch(t,e=>{t.value&&o.update(r.value,e)}),r},Object.defineProperty(e,"__esModule",{value:!0})});
